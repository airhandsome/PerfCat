/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <hwcpipe.h>
#include <adrenopipe.h>
#include <pvrpipe.h>

/* Header for class com_unity_uprtech_nativemodules_NativeWrappers */

#ifndef _Included_com_unity_uprtech_nativemodules_NativeWrappers
#define _Included_com_unity_uprtech_nativemodules_NativeWrappers
#ifdef __cplusplus
extern "C" {
#endif

/*
 * Class:     com_unity_uprtech_nativemodules_NativeWrappers
 * Method:    jni_hwcpipe_start
 * Signature: ()Z
 */

hwcpipe::HWCPipe* profiler;
hwcpipe::HWCPipe * GetProfiler()
{
    return profiler;
}

JNIEXPORT jboolean JNICALL Java_com_unity_uprtech_nativemodules_NativeWrappers_jni_1hwcpipe_1start
        (JNIEnv *, jclass){
    hwcpipe::HWCPipe *pprofiler = hwcpipe::HWCPipe::Instance(
            {hwcpipe::CpuCounter::Cycles, hwcpipe::CpuCounter::Instructions},
            {
                    hwcpipe::GpuCounter::GpuCycles,
                    hwcpipe::GpuCounter::ComputeCycles,
                    hwcpipe::GpuCounter::VertexCycles,
                    hwcpipe::GpuCounter::VertexComputeCycles,
                    hwcpipe::GpuCounter::FragmentCycles,
                    hwcpipe::GpuCounter::TilerCycles,

                    hwcpipe::GpuCounter::ComputeJobs,
                    hwcpipe::GpuCounter::VertexJobs,
                    hwcpipe::GpuCounter::VertexComputeJobs,
                    hwcpipe::GpuCounter::FragmentJobs,

                    hwcpipe::GpuCounter::InputPrimitives,
                    hwcpipe::GpuCounter::CulledPrimitives,
                    hwcpipe::GpuCounter::VisiblePrimitives,

                    hwcpipe::GpuCounter::Tiles,
                    hwcpipe::GpuCounter::TransactionEliminations,

                    hwcpipe::GpuCounter::EarlyZTests,
                    hwcpipe::GpuCounter::EarlyZKilled,
                    hwcpipe::GpuCounter::LateZTests,
                    hwcpipe::GpuCounter::LateZKilled,

                    hwcpipe::GpuCounter::ShaderComputeCycles,
                    hwcpipe::GpuCounter::ShaderFragmentCycles,
                    hwcpipe::GpuCounter::ShaderCycles,
                    hwcpipe::GpuCounter::ShaderArithmeticCycles,
                    hwcpipe::GpuCounter::ShaderInterpolatorCycles,
                    hwcpipe::GpuCounter::ShaderLoadStoreCycles,
                    hwcpipe::GpuCounter::ShaderTextureCycles,

                    hwcpipe::GpuCounter::ExternalMemoryReadAccesses,
                    hwcpipe::GpuCounter::ExternalMemoryWriteAccesses,
                    hwcpipe::GpuCounter::ExternalMemoryReadStalls,
                    hwcpipe::GpuCounter::ExternalMemoryWriteStalls,
                    hwcpipe::GpuCounter::ExternalMemoryReadBytes,
                    hwcpipe::GpuCounter::ExternalMemoryWriteBytes
            });
    pprofiler->run();
    try {
        auto measurements = HWCPIPE()->sample();
        if (measurements.gpu) {
            return true;
        } else {
            pprofiler->stop();
            return false;
        }
    } catch(...) {
        return false;
    }
}

/*
 * Class:     com_unity_uprtech_nativemodules_NativeWrappers
 * Method:    jni_hwcpipe_capture
 * Signature: ()[J
 */
JNIEXPORT jlongArray JNICALL Java_com_unity_uprtech_nativemodules_NativeWrappers_jni_1hwcpipe_1capture
        (JNIEnv *env, jclass){
    const int countersLen = 32;
    jlong counters[countersLen];
    try {
        auto measurements = HWCPIPE()->sample();
        if (measurements.gpu) {
            const auto &gpuCyclesCounter                = measurements.gpu->find(hwcpipe::GpuCounter::GpuCycles);
            const auto &computeCyclesCounter            = measurements.gpu->find(hwcpipe::GpuCounter::ComputeCycles);
            const auto &vertexCyclesCounter             = measurements.gpu->find(hwcpipe::GpuCounter::VertexCycles);
            const auto &vertexComputeCyclesCounter      = measurements.gpu->find(hwcpipe::GpuCounter::VertexComputeCycles);
            const auto &fragmentCyclesCounter           = measurements.gpu->find(hwcpipe::GpuCounter::FragmentCycles);
            const auto &tilerCyclesCounter              = measurements.gpu->find(hwcpipe::GpuCounter::TilerCycles);

            const auto &computeJobsCounter              = measurements.gpu->find(hwcpipe::GpuCounter::ComputeJobs);
            const auto &vertexJobsCounter               = measurements.gpu->find(hwcpipe::GpuCounter::VertexJobs);
            const auto &vertexComputeJobsCounter        = measurements.gpu->find(hwcpipe::GpuCounter::VertexComputeJobs);
            const auto &fragmentsJobsCounter            = measurements.gpu->find(hwcpipe::GpuCounter::FragmentJobs);

            const auto &inputPrimitivesCounter          = measurements.gpu->find(hwcpipe::GpuCounter::InputPrimitives);
            const auto &culledPrimitivesCounter         = measurements.gpu->find(hwcpipe::GpuCounter::CulledPrimitives);
            const auto &visiblePrimitivesCounter        = measurements.gpu->find(hwcpipe::GpuCounter::VisiblePrimitives);

            const auto &tilesCounter                    = measurements.gpu->find(hwcpipe::GpuCounter::Tiles);
            const auto &transactionEliminationsCounter  = measurements.gpu->find(hwcpipe::GpuCounter::TransactionEliminations);

            const auto &earlyZTestsCounter              = measurements.gpu->find(hwcpipe::GpuCounter::EarlyZTests);
            const auto &earlyZKilledCounter             = measurements.gpu->find(hwcpipe::GpuCounter::EarlyZKilled);
            const auto &lateZTestsCounter               = measurements.gpu->find(hwcpipe::GpuCounter::LateZTests);
            const auto &lateZKilledCounter              = measurements.gpu->find(hwcpipe::GpuCounter::LateZKilled);

            const auto &shaderComputeCyclesCounter      = measurements.gpu->find(hwcpipe::GpuCounter::ShaderComputeCycles);
            const auto &shaderFragmentCyclesCounter     = measurements.gpu->find(hwcpipe::GpuCounter::ShaderFragmentCycles);
            const auto &shaderCyclesCounter             = measurements.gpu->find(hwcpipe::GpuCounter::ShaderCycles);
            const auto &shaderArithmeticCyclesCounter   = measurements.gpu->find(hwcpipe::GpuCounter::ShaderArithmeticCycles);
            const auto &shaderInterpolatorCyclesCounter = measurements.gpu->find(hwcpipe::GpuCounter::ShaderInterpolatorCycles);
            const auto &shaderLoadStoreCyclesCounter    = measurements.gpu->find(hwcpipe::GpuCounter::ShaderLoadStoreCycles);
            const auto &shaderTextureCyclesCounter      = measurements.gpu->find(hwcpipe::GpuCounter::ShaderTextureCycles);

            const auto &externalMemoryReadAccessesCounter   = measurements.gpu->find(hwcpipe::GpuCounter::ExternalMemoryReadAccesses);
            const auto &externalMemoryWriteAccessesCounter  = measurements.gpu->find(hwcpipe::GpuCounter::ExternalMemoryWriteAccesses);
            const auto &externalMemoryReadStallsCounter     = measurements.gpu->find(hwcpipe::GpuCounter::ExternalMemoryReadStalls);
            const auto &externalMemoryWriteStallsCounter    = measurements.gpu->find(hwcpipe::GpuCounter::ExternalMemoryWriteStalls);
            const auto &externalMemoryReadBytesCounter      = measurements.gpu->find(hwcpipe::GpuCounter::ExternalMemoryReadBytes);
            const auto &externalMemoryWriteBytesCounter     = measurements.gpu->find(hwcpipe::GpuCounter::ExternalMemoryWriteBytes);


            counters[0]  = (jlong)(gpuCyclesCounter            == measurements.gpu->end() ? 0 : gpuCyclesCounter->second.get<long long>());
            counters[1]  = (jlong)(computeCyclesCounter        == measurements.gpu->end() ? 0 : computeCyclesCounter->second.get<long long>());
            counters[2]  = (jlong)(vertexCyclesCounter         == measurements.gpu->end() ? 0 : vertexCyclesCounter->second.get<long long>());
            counters[3]  = (jlong)(vertexComputeCyclesCounter  == measurements.gpu->end() ? 0 : vertexComputeCyclesCounter->second.get<long long>());
            counters[4]  = (jlong)(fragmentCyclesCounter       == measurements.gpu->end() ? 0 : fragmentCyclesCounter->second.get<long long>());
            counters[5]  = (jlong)(tilerCyclesCounter          == measurements.gpu->end() ? 0 : tilerCyclesCounter->second.get<long long>());

            counters[6]  = (jlong)(computeJobsCounter       == measurements.gpu->end() ? 0 : computeJobsCounter->second.get<long long>());
            counters[7]  = (jlong)(vertexJobsCounter        == measurements.gpu->end() ? 0 : vertexJobsCounter->second.get<long long>());
            counters[8]  = (jlong)(vertexComputeJobsCounter == measurements.gpu->end() ? 0 : vertexComputeJobsCounter->second.get<long long>());
            counters[9]  = (jlong)(fragmentsJobsCounter     == measurements.gpu->end() ? 0 : fragmentsJobsCounter->second.get<long long>());

            counters[10] = (jlong)(inputPrimitivesCounter   == measurements.gpu->end() ? 0 : inputPrimitivesCounter->second.get<long long>());
            counters[11] = (jlong)(culledPrimitivesCounter  == measurements.gpu->end() ? 0 : culledPrimitivesCounter->second.get<long long>());
            counters[12] = (jlong)(visiblePrimitivesCounter == measurements.gpu->end() ? 0 : visiblePrimitivesCounter->second.get<long long>());

            counters[13] = (jlong)(tilesCounter                    == measurements.gpu->end() ? 0 : tilesCounter->second.get<long long>());
            counters[14] = (jlong)(transactionEliminationsCounter  == measurements.gpu->end() ? 0 : transactionEliminationsCounter->second.get<long long>());

            counters[15] = (jlong)(earlyZTestsCounter  == measurements.gpu->end() ? 0 : earlyZTestsCounter->second.get<long long>());
            counters[16] = (jlong)(earlyZKilledCounter == measurements.gpu->end() ? 0 : earlyZKilledCounter->second.get<long long>());
            counters[17] = (jlong)(lateZTestsCounter   == measurements.gpu->end() ? 0 : lateZTestsCounter->second.get<long long>());
            counters[18] = (jlong)(lateZKilledCounter  == measurements.gpu->end() ? 0 : lateZKilledCounter->second.get<long long>());

            counters[19] = (jlong)(shaderComputeCyclesCounter      == measurements.gpu->end() ? 0 : shaderComputeCyclesCounter->second.get<long long>());
            counters[20] = (jlong)(shaderFragmentCyclesCounter     == measurements.gpu->end() ? 0 : shaderFragmentCyclesCounter->second.get<long long>());
            counters[21] = (jlong)(shaderCyclesCounter             == measurements.gpu->end() ? 0 : shaderCyclesCounter->second.get<long long>());
            counters[22] = (jlong)(shaderArithmeticCyclesCounter   == measurements.gpu->end() ? 0 : shaderArithmeticCyclesCounter->second.get<long long>());
            counters[23] = (jlong)(shaderInterpolatorCyclesCounter == measurements.gpu->end() ? 0 : shaderInterpolatorCyclesCounter->second.get<long long>());
            counters[24] = (jlong)(shaderLoadStoreCyclesCounter    == measurements.gpu->end() ? 0 : shaderLoadStoreCyclesCounter->second.get<long long>());
            counters[25] = (jlong)(shaderTextureCyclesCounter      == measurements.gpu->end() ? 0 : shaderTextureCyclesCounter->second.get<long long>());

            counters[26] = (jlong)(externalMemoryReadAccessesCounter  == measurements.gpu->end() ? 0 : externalMemoryReadAccessesCounter->second.get<long long>());
            counters[27] = (jlong)(externalMemoryWriteAccessesCounter == measurements.gpu->end() ? 0 : externalMemoryWriteAccessesCounter->second.get<long long>());
            counters[28] = (jlong)(externalMemoryReadStallsCounter    == measurements.gpu->end() ? 0 : externalMemoryReadStallsCounter->second.get<long long>());
            counters[29] = (jlong)(externalMemoryWriteStallsCounter   == measurements.gpu->end() ? 0 : externalMemoryWriteStallsCounter->second.get<long long>());
            counters[30] = (jlong)(externalMemoryReadBytesCounter     == measurements.gpu->end() ? 0 : externalMemoryReadBytesCounter->second.get<long long>());
            counters[31] = (jlong)(externalMemoryWriteBytesCounter    == measurements.gpu->end() ? 0 : externalMemoryWriteBytesCounter->second.get<long long>());

        }
        jlongArray outArr = (*env).NewLongArray(countersLen);
        (*env).SetLongArrayRegion(outArr, 0, countersLen, counters);
        return outArr;
    }
    catch(...) {
        jlongArray outArr = (*env).NewLongArray(countersLen);
        (*env).SetLongArrayRegion(outArr, 0, countersLen, counters);
        return outArr;
    }
}

/*
 * Class:     com_unity_uprtech_nativemodules_NativeWrappers
 * Method:    jni_adreno_start
 * Signature: ()Z
 */
JNIEXPORT jint JNICALL Java_com_unity_uprtech_nativemodules_NativeWrappers_jni_1adreno_1start(JNIEnv *env, jclass clazz) {
    // TODO: implement jni_adreno_start()

    try {
        AdrenoPipe *pprofiler = AdrenoPipe::Instance();
        int type = pprofiler->run();
        if (type < 0)
        {
            return -1;
        }
        int status = pprofiler->sample();
        if (status < 0) return -1;
        return type;
    } catch(...) {
        return -1;
    }
}

/*
 * Class:     com_unity_uprtech_nativemodules_NativeWrappers
 * Method:    jni_adreno_capture
 * Signature: ()[J
 */
JNIEXPORT jlongArray JNICALL Java_com_unity_uprtech_nativemodules_NativeWrappers_jni_1adreno_1capture(JNIEnv *env, jclass clazz) {

    // TODO: implement jni_adreno_capture()
    try {
        AdrenoPipe *pprofiler = AdrenoPipe::Instance();
        int status = pprofiler->sample();

        int countersLen = status;
        jlong counters[countersLen];
        jlongArray outArr = (*env).NewLongArray(countersLen);
        for(int i = 0; i < countersLen; i++){
            counters[i] = (jlong)(pprofiler -> values[i]);
        }
        (*env).SetLongArrayRegion(outArr, 0, countersLen, counters);
        return outArr;

    }
    catch(...) {
        return (*env).NewLongArray(0);
    }
}



JNIEXPORT jboolean JNICALL
Java_com_unity_uprtech_nativemodules_NativeWrappers_initPVRScope(JNIEnv *env, jclass clazz) {
    // TODO: implement initPVRScope()
    try {
        PVRPipe *pprofiler = PVRPipe::Instance();

        return pprofiler->initGpuCounter();
    } catch(...) {
        return false;
    }
}

JNIEXPORT jboolean JNICALL
Java_com_unity_uprtech_nativemodules_NativeWrappers_deinitPVRScope(JNIEnv *env, jclass clazz) {
    // TODO: implement deinitPVRScope()
    return PVRPipe::Instance()->deInitGpuCounter();
}

JNIEXPORT jintArray JNICALL
Java_com_unity_uprtech_nativemodules_NativeWrappers_returnCPUMetrics(JNIEnv *env, jclass clazz) {
    // TODO: implement returnCPUMetrics()
    PVRPipe *pprofiler = PVRPipe::Instance();
    pprofiler->pCPUMetrics->updateCPU();
    unsigned int nNumCores = pprofiler->pCPUMetrics->getNumCores();

    //-- No error handling is being done...
    jint* buf = new jint[nNumCores];
    memset (buf, 0, nNumCores);

    for (unsigned int i = 0; i < nNumCores; ++i)
    {
        float load = pprofiler->pCPUMetrics->getCPULoad(i);
        buf[i] = (unsigned char) (load + 0.5);
    }

    jintArray ret = env->NewIntArray(nNumCores);
    env->SetIntArrayRegion (ret, 0, nNumCores, buf);

    delete[] buf;
    return ret;

}

JNIEXPORT jfloatArray JNICALL
Java_com_unity_uprtech_nativemodules_NativeWrappers_returnPVRScope(JNIEnv *env, jclass clazz) {
    // TODO: implement returnPVRScope()
    size_t numCounters  = 0;
    PVRPipe *pprofiler = PVRPipe::Instance();
    pprofiler->pPVRScopeHUD->readCounters(true);

    numCounters = pprofiler->pPVRScopeHUD->getNumCounters();
    LOGE("Number of counters: %d", (int)numCounters);

    jfloat * buf = new jfloat[numCounters];
    memset (buf, 0, numCounters);

    for(unsigned int i = 0; i < numCounters; i++)
    {
        float temp = pprofiler->pPVRScopeHUD->getCounter(i);
        buf[i] = temp;
    }

    jfloatArray ret = env->NewFloatArray((jsize)numCounters);
    env->SetFloatArrayRegion (ret, 0, (jsize)numCounters, buf);

    delete[] buf;
    return ret;
}

JNIEXPORT jobjectArray JNICALL
Java_com_unity_uprtech_nativemodules_NativeWrappers_returnPVRScopeStrings(JNIEnv *env,
                                                                          jclass clazz) {
    // TODO: implement returnPVRScopeStrings()
    PVRPipe *pprofiler = PVRPipe::Instance();
    size_t numCounters  = 0;

    pprofiler->pPVRScopeHUD->readCounters(true);


    numCounters = pprofiler->pPVRScopeHUD->getNumCounters();

    jobjectArray ret = env->NewObjectArray((jsize)numCounters, env->FindClass("java/lang/String"), 0);
    for(unsigned int i = 0; i < numCounters; i++)
    {
        const char* temp = pprofiler->pPVRScopeHUD->getName(i).c_str();
        jstring str = env->NewStringUTF(temp);
        env->SetObjectArrayElement(ret, i, str);
    }

    return ret;
}


#ifdef __cplusplus
}
#endif
#endif


